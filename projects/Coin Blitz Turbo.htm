<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Skyline R32 Coin Rush</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
      color: #fff;
    }

    /* HUD */
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.55);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
    }
    #hud span { margin-right: 12px; }

    /* Time Bar */
    #timeBarContainer {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      height: 18px;
      background: rgba(255,255,255,0.25);
      border: 2px solid #fff;
      border-radius: 10px;
      overflow: hidden;
      z-index: 10;
    }
    #timeBar {
      height: 100%;
      width: 100%;
      background: #00ff66;
      transition: width 0.1s linear;
    }

    /* Boost Bar */
    #boostBarContainer {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 20px;
      background: rgba(255,255,255,0.2);
      border: 2px solid #fff;
      border-radius: 10px;
      overflow: hidden;
      z-index: 10;
    }
    #boostBar {
      height: 100%;
      width: 100%;
      background: #00ccff;
      transition: width 0.1s linear;
    }

    /* Speedometer */
    #speedometer {
      position: fixed;
      bottom: 60px;
      right: 20px;
      font-size: 22px;
      background: rgba(0,0,0,0.5);
      padding: 10px 16px;
      border-radius: 8px;
      z-index: 10;
    }

    /* Mini-map */
    #minimap {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 160px;
      height: 160px;
      border: 3px solid #fff;
      border-radius: 4px;
      background: rgba(0,0,0,0.6);
      z-index: 10;
    }

    /* Pause label */
    #pauseLabel {
      position: fixed;
      top: 10px;
      right: 200px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.55);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      opacity: 0.7;
    }

    /* Game Over */
    #gameOver {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0, 0, 0, 0.85);
      padding: 20px 30px;
      border-radius: 8px;
      text-align: center;
      font-size: 22px;
      display: none;
    }
    #gameOver button {
      margin-top: 12px;
      padding: 8px 16px;
      background: #1e90ff;
      border: none;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 16px;
    }
  </style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <span id="scoreLabel">Coins: 0</span>
  <span id="levelLabel">Level: 1</span>
  <span id="timerLabel">Time: 60.0</span>
</div>

<!-- Time Bar -->
<div id="timeBarContainer">
  <div id="timeBar"></div>
</div>

<!-- Boost Bar -->
<div id="boostBarContainer">
  <div id="boostBar"></div>
</div>

<!-- Speedometer -->
<div id="speedometer">0 MPH</div>

<!-- Mini-map -->
<canvas id="minimap" width="160" height="160"></canvas>

<!-- Pause Label -->
<div id="pauseLabel">Space: Pause | Ctrl: Boost</div>

<!-- Game Over -->
<div id="gameOver">
  <div>Game Over!</div>
  <div style="font-size:14px;margin-top:6px;">You ran out of time.</div>
  <button id="restartBtn">Restart</button>
</div>

<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

<script>
(function () {

  let scene, camera, renderer;

  // Car physics (non-drift)
  let car;
  let carAngle = 0;
  let carVelocity = 0;
  const accel = 0.04;
  const maxSpeed = 0.9;
  const reverseSpeed = -0.4;
  const friction = 0.02;
  const steerStrength = 0.035;

  // Boost system
  let boostReady = 1;
  const boostDrain = 0.015;
  const boostRegen = 0.005;
  const boostMultiplier = 2.5;

  // Pause system
  let paused = false;

  const keys = { up: false, down: false, left: false, right: false, boost: false };

  // World
  let ground;
  const worldSize = 900;
  const baseCoinCount = 30;
  let coins = [];
  let buildings = [];

  // Game state
  let clock = new THREE.Clock();
  let timeRemaining = 60;
  const coinBonusTime = 5;
  let currentMaxTime = 60;
  const minMaxTime = 20;
  let score = 0;
  let level = 1;
  let gameOver = false;

  // HUD elements
  const scoreLabel = document.getElementById('scoreLabel');
  const levelLabel = document.getElementById('levelLabel');
  const timerLabel = document.getElementById('timerLabel');
  const boostBar = document.getElementById('boostBar');
  const speedometer = document.getElementById('speedometer');
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas.getContext('2d');
  const gameOverDiv = document.getElementById('gameOver');
  const restartBtn = document.getElementById('restartBtn');

  let tailLights = [];

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202040);

    camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      5000
    );

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lights
    const hemiLight = new THREE.HemisphereLight(0xffeedd, 0x080820, 0.9);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(150, 250, 150);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(worldSize, worldSize);
    const groundMat = new THREE.MeshPhongMaterial({
      color: 0x228866,
      shininess: 15
    });
    ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Car
    buildCarR32();

    // Level content
    generateLevelContent();

    updateCameraPosition();
    updateHUD();
    updateBoostBar();
    updateTimeBar();
    updateSpeedometer();

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);
    restartBtn.addEventListener('click', restartGame);
  }

  // Build boxy R32-style car
  function buildCarR32() {
    car = new THREE.Group();

    const bodyGeo = new THREE.BoxGeometry(4.6, 1.2, 9.2);
    const bodyMat = new THREE.MeshPhongMaterial({
      color: 0x0033ff,
      shininess: 80
    });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.set(0, 1.0, 0);
    body.castShadow = true;
    car.add(body);

    const hoodGeo = new THREE.BoxGeometry(4.4, 0.4, 2.4);
    const hood = new THREE.Mesh(hoodGeo, bodyMat);
    hood.position.set(0, 1.4, 3.8);
    hood.castShadow = true;
    car.add(hood);

    const cabinGeo = new THREE.BoxGeometry(3.6, 1.0, 3.6);
    const cabin = new THREE.Mesh(cabinGeo, bodyMat);
    cabin.position.set(0, 2.0, -0.8);
    cabin.castShadow = true;
    car.add(cabin);

    const bumperGeo = new THREE.BoxGeometry(4.6, 0.8, 1.0);
    const bumperMat = new THREE.MeshPhongMaterial({ color: 0x001199 });
    const bumper = new THREE.Mesh(bumperGeo, bumperMat);
    bumper.position.set(0, 0.7, 5.0);
    bumper.castShadow = true;
    car.add(bumper);

    const grilleGeo = new THREE.BoxGeometry(2.0, 0.3, 0.2);
    const grilleMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
    const grille = new THREE.Mesh(grilleGeo, grilleMat);
    grille.position.set(0, 0.9, 5.1);
    car.add(grille);

    const headGeo = new THREE.BoxGeometry(0.9, 0.4, 0.2);
    const headMat = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      emissive: 0xddddff,
      emissiveIntensity: 1.2
    });
    const headL = new THREE.Mesh(headGeo, headMat);
    const headR = new THREE.Mesh(headGeo, headMat);
    headL.position.set(-1.2, 1.0, 5.15);
    headR.position.set(1.2, 1.0, 5.15);
    car.add(headL, headR);

    const tailGeo = new THREE.BoxGeometry(0.7, 0.7, 0.2);
    const tailMatBase = {
      color: 0xff3333,
      emissive: 0xaa0000,
      emissiveIntensity: 0.25
    };
    const tailL = new THREE.Mesh(tailGeo, new THREE.MeshPhongMaterial(tailMatBase));
    const tailR = new THREE.Mesh(tailGeo, new THREE.MeshPhongMaterial(tailMatBase));
    tailL.position.set(-1.3, 1.2, -5.1);
    tailR.position.set(1.3, 1.2, -5.1);
    car.add(tailL, tailR);
    tailLights = [tailL, tailR];

    const wheelGeo = new THREE.CylinderGeometry(0.85, 0.85, 0.6, 20);
    const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
    const wheelPositions = [
      [1.8, 0.6, 3.4],
      [-1.8, 0.6, 3.4],
      [1.8, 0.6, -3.4],
      [-1.8, 0.6, -3.4]
    ];
    wheelPositions.forEach(pos => {
      const wheel = new THREE.Mesh(wheelGeo, wheelMat);
      wheel.rotation.z = Math.PI / 2;
      wheel.position.set(pos[0], pos[1], pos[2]);
      wheel.castShadow = true;
      car.add(wheel);
    });

    const spoilerGeo = new THREE.BoxGeometry(3.0, 0.2, 0.6);
    const spoilerMat = new THREE.MeshPhongMaterial({ color: 0x001177 });
    const spoiler = new THREE.Mesh(spoilerGeo, spoilerMat);
    spoiler.position.set(0, 2.0, -4.4);
    spoiler.castShadow = true;
    car.add(spoiler);

    car.userData.box = new THREE.Box3();
    car.position.set(0, 0, 0);
    scene.add(car);
  }

  // Level generation (grey buildings + coins) with fixed hitboxes
  function generateLevelContent() {
    coins.forEach(c => scene.remove(c.mesh));
    buildings.forEach(b => scene.remove(b));
    coins = [];
    buildings = [];

    const buildingCount = 60 + level * 10;

    for (let i = 0; i < buildingCount; i++) {
      const width = 12 + Math.random() * 20;
      const depth = 12 + Math.random() * 20;
      const height = 15 + Math.random() * 60;

      const geom = new THREE.BoxGeometry(width, height, depth);
      const mat = new THREE.MeshPhongMaterial({
        color: 0x777777,
        shininess: 25
      });

      const mesh = new THREE.Mesh(geom, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      const minRadius = 45;
      const maxRadius = worldSize * 0.45;
      const angle = Math.random() * Math.PI * 2;
      const radius = minRadius + Math.random() * (maxRadius - minRadius);
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      mesh.position.set(x, height / 2, z);
      scene.add(mesh);

      // Windows (visual only)
      const floors = Math.max(2, Math.floor(height / 8));
      const windowsPerSide = 4;
      const windowMat = new THREE.MeshPhongMaterial({
        color: 0x222244,
        emissive: 0x3355ff,
        emissiveIntensity: 0.5
      });

      for (let f = 1; f < floors - 1; f++) {
        const y = -height / 2 + f * (height / floors) + 1.5;
        for (let s = 0; s < windowsPerSide; s++) {
          const offset = ((s + 0.5) / windowsPerSide - 0.5) * (width * 0.8);
          const wGeo = new THREE.BoxGeometry(width / windowsPerSide * 0.4, 1.2, 0.2);

          const wFront = new THREE.Mesh(wGeo, windowMat);
          wFront.position.set(offset, y, depth / 2 + 0.11);
          mesh.add(wFront);

          const wBack = new THREE.Mesh(wGeo, windowMat);
          wBack.position.set(offset, y, -depth / 2 - 0.11);
          mesh.add(wBack);
        }
      }

      // FIXED HITBOX: clean box ignoring window children
      const halfW = width / 2;
      const halfD = depth / 2;
      const halfH = height / 2;

      const localBox = new THREE.Box3(
        new THREE.Vector3(-halfW, -halfH, -halfD),
        new THREE.Vector3( halfW,  halfH,  halfD)
      );

      mesh.updateMatrixWorld(true);
      localBox.applyMatrix4(mesh.matrixWorld);
      mesh.userData.box = localBox;

      buildings.push(mesh);
    }

    for (let i = 0; i < baseCoinCount; i++) {
      createCoin();
    }
  }

  function createCoin() {
    const coinGeo = new THREE.TorusGeometry(1, 0.3, 12, 24);
    const coinMat = new THREE.MeshPhongMaterial({
      color: 0xffee00,
      emissive: 0x553300,
      emissiveIntensity: 0.7
    });
    const coinMesh = new THREE.Mesh(coinGeo, coinMat);
    coinMesh.castShadow = true;

    const minRadius = 12;
    const maxRadius = worldSize * 0.45;
    const angle = Math.random() * Math.PI * 2;
    const radius = minRadius + Math.random() * (maxRadius - minRadius);
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    coinMesh.position.set(x, 2.0, z);
    scene.add(coinMesh);

    coins.push({ mesh: coinMesh, collected: false });
  }

  // Input
  function onKeyDown(e) {
    if (e.code === 'Space') {
      if (!gameOver) paused = !paused;
      return;
    }
    if (paused || gameOver) return;

    if (e.code === 'ArrowUp') keys.up = true;
    if (e.code === 'ArrowDown') keys.down = true;
    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'ControlLeft' || e.code === 'ControlRight') keys.boost = true;
  }

  function onKeyUp(e) {
    if (e.code === 'ArrowUp') keys.up = false;
    if (e.code === 'ArrowDown') keys.down = false;
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
    if (e.code === 'ControlLeft' || e.code === 'ControlRight') keys.boost = false;
  }

  // Game loop
  function update(delta) {
    if (paused || gameOver) return;

    // Timer
    timeRemaining -= delta;
    if (timeRemaining <= 0) {
      timeRemaining = 0;
      updateHUD();
      updateTimeBar();
      triggerGameOver();
      return;
    }

    // Acceleration / reverse
    if (keys.up) carVelocity += accel;
    if (keys.down) carVelocity -= accel;

    // Boost logic with higher cap
    if (keys.boost && boostReady > 0.1) {
      boostReady -= boostDrain;
      const boostedMax = maxSpeed * boostMultiplier;
      carVelocity += accel * 1.5;
      if (carVelocity > boostedMax) carVelocity = boostedMax;
    } else {
      boostReady += boostRegen;
    }
    boostReady = Math.min(1, Math.max(0, boostReady));
    updateBoostBar();

    // Clamp speed (boost overrides normal max)
    if (keys.boost && boostReady > 0.1) {
      const boostedMax = maxSpeed * boostMultiplier;
      carVelocity = Math.min(carVelocity, boostedMax);
    } else {
      carVelocity = Math.min(carVelocity, maxSpeed);
    }
    carVelocity = Math.max(carVelocity, reverseSpeed);

    // Friction
    if (!keys.up && !keys.down) {
      if (carVelocity > 0) {
        carVelocity -= friction;
        if (carVelocity < 0) carVelocity = 0;
      } else if (carVelocity < 0) {
        carVelocity += friction;
        if (carVelocity > 0) carVelocity = 0;
      }
    }

    // Steering
    if (carVelocity !== 0) {
      const steerDir = carVelocity > 0 ? 1 : -1;
      if (keys.left) carAngle += steerStrength * steerDir;
      if (keys.right) carAngle -= steerStrength * steerDir;
    }

    const prevX = car.position.x;
    const prevZ = car.position.z;
    const dx = Math.sin(carAngle) * carVelocity;
    const dz = Math.cos(carAngle) * carVelocity;
    car.position.x += dx;
    car.position.z += dz;
    car.rotation.y = carAngle;

    const margin = worldSize * 0.48;
    car.position.x = THREE.MathUtils.clamp(car.position.x, -margin, margin);
    car.position.z = THREE.MathUtils.clamp(car.position.z, -margin, margin);

    car.userData.box.setFromObject(car);

    // Building collisions (using fixed world-space boxes)
    for (let i = 0; i < buildings.length; i++) {
      const b = buildings[i];
      if (b.userData.box && b.userData.box.intersectsBox(car.userData.box)) {
        car.position.x = prevX;
        car.position.z = prevZ;
        carVelocity *= -0.2;
        car.userData.box.setFromObject(car);
        break;
      }
    }

    // Brake lights
    const braking = keys.down || carVelocity < -0.05;
    tailLights.forEach(t => {
      t.material.emissiveIntensity = braking ? 1.4 : 0.25;
    });

    // Coin collection
    const carRadius = 3.0;
    const coinRadius = 2.0;
    const collectDistSq = (carRadius + coinRadius) * (carRadius + coinRadius);

    for (let i = 0; i < coins.length; i++) {
      const c = coins[i];
      c.mesh.rotation.y += delta * 2.5;

      const dxC = c.mesh.position.x - car.position.x;
      const dzC = c.mesh.position.z - car.position.z;
      const distSq = dxC * dxC + dzC * dzC;

      if (distSq < collectDistSq) {
        scene.remove(c.mesh);
        coins.splice(i, 1);
        i--;

        score++;
        timeRemaining = Math.min(timeRemaining + coinBonusTime, currentMaxTime);
        createCoin();

        const newLevel = Math.floor(score / 20) + 1;
        if (newLevel !== level) {
          level = newLevel;
          currentMaxTime = Math.max(minMaxTime, 60 - (level - 1) * 5);
          generateLevelContent();
        }

        updateTimeBar();
      }
    }

    updateCameraPosition();
    updateHUD();
    updateTimeBar();
    updateSpeedometer();
    drawMinimap();
  }

  function updateCameraPosition() {
    const distanceBehind = 22;
    const height = 9;
    const offsetX = Math.sin(carAngle) * -distanceBehind;
    const offsetZ = Math.cos(carAngle) * -distanceBehind;

    camera.position.set(
      car.position.x + offsetX,
      car.position.y + height,
      car.position.z + offsetZ
    );
    camera.lookAt(car.position.x, car.position.y + 2, car.position.z);
  }

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    update(delta);
    renderer.render(scene, camera);
  }

  // HUD helpers
  function updateHUD() {
    scoreLabel.textContent = "Coins: " + score;
    levelLabel.textContent = "Level: " + level;
    timerLabel.textContent = "Time: " + timeRemaining.toFixed(1);
  }

  function updateBoostBar() {
    boostBar.style.width = (boostReady * 100) + "%";
  }

  function updateTimeBar() {
    const pct = timeRemaining / currentMaxTime;
    const clamped = Math.max(0, Math.min(1, pct));
    const bar = document.getElementById("timeBar");
    bar.style.width = (clamped * 100) + "%";

    if (clamped > 0.5) bar.style.background = "#00ff66";
    else if (clamped > 0.25) bar.style.background = "#ffff33";
    else bar.style.background = "#ff3333";
  }

  function updateSpeedometer() {
    const speed = Math.abs(carVelocity);
    const mph = Math.round(speed * 70); // more street-legal scaling
    speedometer.textContent = mph + " MPH";
  }

  // Minimap
  function drawMinimap() {
    const ctx = minimapCtx;
    const w = minimapCanvas.width;
    const h = minimapCanvas.height;
    ctx.clearRect(0, 0, w, h);

    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, w, h);

    ctx.strokeStyle = "#555";
    ctx.strokeRect(5, 5, w - 10, h - 10);

    const scale = (w - 20) / (worldSize * 2);
    const cx = w / 2;
    const cy = h / 2;

    ctx.fillStyle = "#888";
    buildings.forEach(b => {
      const x = b.position.x * scale;
      const z = b.position.z * scale;
      const size = 4;
      ctx.fillRect(cx + x - size / 2, cy + z - size / 2, size, size);
    });

    ctx.fillStyle = "#ff0";
    coins.forEach(c => {
      const x = c.mesh.position.x * scale;
      const z = c.mesh.position.z * scale;
      ctx.fillRect(cx + x - 2, cy + z - 2, 4, 4);
    });

    ctx.fillStyle = "#0ff";
    const px = car.position.x * scale;
    const pz = car.position.z * scale;
    ctx.beginPath();
    ctx.arc(cx + px, cy + pz, 4, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "#0ff";
    ctx.beginPath();
    const dirX = Math.sin(carAngle) * 10;
    const dirZ = Math.cos(carAngle) * 10;
    ctx.moveTo(cx + px, cy + pz);
    ctx.lineTo(cx + px + dirX, cy + pz + dirZ);
    ctx.stroke();
  }

  function triggerGameOver() {
    gameOver = true;
    gameOverDiv.style.display = "block";
  }

  function restartGame() {
    score = 0;
    level = 1;
    timeRemaining = 60;
    currentMaxTime = 60;
    carVelocity = 0;
    carAngle = 0;
    car.position.set(0, 0, 0);
    boostReady = 1;
    paused = false;
    gameOver = false;
    gameOverDiv.style.display = "none";
    generateLevelContent();
    clock = new THREE.Clock();
    updateHUD();
    updateBoostBar();
    updateTimeBar();
    updateSpeedometer();
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

})();
</script>
</body>
</html>
